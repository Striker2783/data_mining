use std::{
    collections::HashSet,
    ops::{Deref, DerefMut},
};

use datasets::transaction_set::TransactionSet;

use crate::{
    apriori::{apriori_run_one, apriori_run_two, AprioriCandidates},
    apriori_tid::AprioriTiDCandidates,
    candidates::Candidates,
    hash_tree::AprioriHashTree,
    transaction_id::{TransactionID, TransactionIDs},
};
/// The AprioriHybrid Algorithm
pub struct AprioriHybrid {
    min_support: u64,
    /// When to switch to using AprioriTID
    switch: usize,
}

impl AprioriHybrid {
    /// Constructor
    pub fn new(min_support: u64, switch: usize) -> Self {
        AprioriHybrid {
            min_support,
            switch,
        }
    }
    /// Runs the algorithm
    pub fn run(&self, data: &TransactionSet) -> Vec<Candidates> {
        // The frequent itemsets generated by Apriori
        let mut apriori = vec![apriori_run_one(data, self.min_support), apriori_run_two(data, self.min_support)];
        let mut prev_trans = Vec::new();
        for d in data.iter() {
            prev_trans.push(TransactionHybrid::new(d.clone()));
        }
        for i in 2.. {
            let prev = apriori.last().unwrap();
            let mut tree = AprioriCandidates::new(prev).create_tree();
            for t in prev_trans.iter_mut() {
                t.count(&mut tree, i);
            }
            let s: HashSet<_> = tree
                .iter()
                .filter(|&(_, n)| n >= self.min_support)
                .map(|(v, _)| v.to_vec())
                .collect();
            if s.is_empty() {
                break;
            }
            let c = Candidates::new(s);
            apriori.push(c);
        }
        apriori
    }
}
#[derive(Debug)]
pub enum TransactionType {
    Array(Vec<usize>),
    TID(TransactionID),
}
pub struct TransactionHybrid {
    curr: TransactionType,
    prev: usize,
}
impl TransactionHybrid {
    pub fn new(curr: Vec<usize>) -> Self {
        Self {
            curr: TransactionType::Array(curr),
            prev: 0,
        }
    }

    pub fn count(&mut self, counter: &mut AprioriHashTree, i: usize) {
        match &mut self.curr {
            TransactionType::Array(items) => {
                let s = TransactionID::from_transaction(&items, i, counter);
                if s.ids().len() < self.prev {
                    self.curr = TransactionType::TID(s)
                } else {
                    self.prev = s.ids().len();
                }
            }
            TransactionType::TID(transaction_id) => {
                *transaction_id = transaction_id.count(counter.deref_mut());
            }
        }
    }
}
#[cfg(test)]
mod tests {
    use datasets::transaction_set::TransactionSet;

    use crate::apriori_hybrid::AprioriHybrid;

    #[test]
    fn test_apriori_tid() {
        let example = TransactionSet::new(
            vec![
                vec![0, 1, 4],
                vec![1, 3],
                vec![1, 2],
                vec![0, 1, 3],
                vec![0, 2],
                vec![1, 2],
                vec![0, 2],
                vec![0, 1, 2, 4],
                vec![0, 1, 2],
            ],
            5,
        );
        let apriori = AprioriHybrid::new(2, 3);
        let result = apriori.run(&example);
        assert_eq!(result.len(), 3);
        assert_eq!(result[0].len(), 5);
        assert_eq!(result[1].len(), 6);
        assert_eq!(result[2].len(), 2);
    }
}
